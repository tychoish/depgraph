package depgraph

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/pkg/errors"
)

// Graph contains a fully materialized graph including all nodes
// (files, symbols, libraries, artifacts) along with its denormalized
// relationships, as well as the nornmalized relationships.
type Graph struct {
	Edges   []Edge `json:"edges"`
	Nodes   []Node `json:"nodes"`
	BuildID string `json:"id,omitempty"`

	mapsPopulated bool
	edges         map[string]Edge
	nodes         map[string]Node

	nodeIndex map[int64]Node
	edgeIndex map[int64]Edge
	nextID    int64
}

// Node represents a single item in the graph, either a symbol, file,
// artifact or library. The Relationship attribute contains some
// denormalized information about a node's relationships to other nodes.
type Node struct {
	Name          string `json:"id" bson:"name"`
	GraphID       int64  `bson:"index" json:"index"`
	Relationships struct {
		Type NodeType `json:"type" bson:"type"`
	} `json:"node" bson:"-,inline"`
}

// ID returns a locally unique identifier for this node. Used to
// implement an interface the Graph algorithms library.
func (n *Node) ID() int64 { return n.GraphID }

// Type provides a more convenient accessor for data in this embedded field.
//
// In the format generated by the tool, there is a large amount of
// denormalized data, which we hope to track in this implementation in
// a more straight forward way.
func (n *Node) Type() NodeType { return n.Relationships.Type }

// NodeRelationship represents a single edge in the graph,
type NodeRelationship struct {
	GraphID int64  `bson:"index" json:"index"`
	Name    string `json:"id" bson:"name"`
}

// Represents a single group of edges in the (directed) graph, which contains
// which kind of relationship a list of "to" nodes and the originating node.
type Edge struct {
	Type     EdgeType           `json:"type" bson:"type"`
	FromNode NodeRelationship   `bson:"from_node" json:"from_node"`
	ToNodes  []NodeRelationship `bson:"to_node" json:"to_node"`
	localID  int64
}

// Name returns a dep-graph specific id for this node, which combines the
func (e Edge) Name() string { return fmt.Sprintf("%d.%d", e.FromNode.GraphID, e.Type) }

// ID returns the graph-system unique id for this edge.
func (e Edge) ID() int64 { return e.localID }

// From provides the unique ID of the "from" edge. Implemented to
// support gonum/graph algorithms.
func (e Edge) From() int64 { return e.FromNode.GraphID }

// To returns the unique graph system id of the first target node
// defined in the edge. It ignores additional targets in the current
// implemenation.
//
// TODO: when we denormalize edges and create a single edge for each
// node, this should panic when there are no to nodes, or more than
// one to node.
func (e Edge) To() int64 {
	if len(e.ToNodes) == 0 {
		return -1
	}

	return e.ToNodes[0].GraphID
}

// New parses a graph and returns the graph structure. New takes a
// build id and a path to the graph source. The path may either be a
// URL which it will download into the current directory, or the location
// of a local file.
func New(build, path string) (*Graph, error) {
	var data []byte
	var err error

	if strings.HasPrefix(path, "http") {
		data, err = cacheDownload(300*time.Hour, path, filepath.Base(path), false)
		if err != nil {
			return nil, errors.Wrap(err, "problem downloading file")
		}
	} else if _, err = os.Stat(path); os.IsNotExist(err) {
		return nil, errors.Errorf("could not find file %s", path)
	} else {
		data, err = ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
	}

	g := &Graph{}

	if err = json.Unmarshal(data, g); err != nil {
		return nil, errors.Wrap(err, "problem reading json")
	}
	g.refresh() // populate the maps
	g.BuildID = build

	return g, nil
}
